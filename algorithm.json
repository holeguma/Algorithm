{
	"ModInt": {
		"prefix": "mod",
		"body": [
			"static long mod=${1:(long)1e9+7};",
			"",
			"static long add(long a, long b) {",
				"\treturn (a + b) % mod;",
			"}",
			"",
			"static long sub(long a, long b) {",
				"\tlong d = a - b;",
				"\twhile (d < 0)",
					"\t\td += mod;",
				"\treturn d;",
			"}",
			"",
			"static long mul(long a, long b) {",
				"\treturn a * b % mod;",
			"}",
			"",
			"static long div(long a, long b) {",
				"\treturn a * mod_inverse(b) % mod;",
			"}",
			"",
			"public static long[] fact(int n) {",
				"\tlong[] ret = new long[n + 1];",
				"\tret[0] = 1 % mod;",
				"\tfor (int i = 1; i <= n; i++) {",
					"\t\tret[i] = mul(ret[i - 1], i);",
				"\t}",
				"\treturn ret;",
			"}",
			"",
			"private static long[] factInv(int n) {",
				"\tlong[] ret = new long[n + 1];",
				"\tret[0] = 1;",
				"\tfor (int i = 1; i <= n; i++) {",
					"\t\tret[i] = div(ret[i - 1], i);",
				"\t}",
				"\treturn ret;",
			"}",
			"",
			"public static long comb(int n, int m, long[] fact, long[] factInv) {",
				"\tlong ret = fact[n];",
				"\tret = mul(ret, factInv[m]);",
				"\tret = mul(ret, factInv[n - m]);",
				"\treturn ret;",
			"}",
			"",
			"public static long[][] stirling(int n) {",
				"\tlong[][] ret = new long[n + 1][n + 1];",
				"\tret[0][0] = 1;",
				"\tfor (int i = 1; i <= n; i++)",
					"\t\tfor (int j = 1; j <= i; j++)",
						"\t\t\tret[i][j] = add(ret[i - 1][j - 1], mul(ret[i - 1][j], j));",
				"\treturn ret;",
			"}",
			"",
			"public static long mod_inverse(long a) {",
				"\tlong[] ret = extgcd(a, mod);",
				"\treturn add(mod, ret[0] % mod);",
			"}",
			"",
			"private static long[] extgcd(long a, long b) {",
				"\tlong[] ret = new long[3];",
				"\tret[2] = _extgcd(a, b, ret);",
				"\treturn ret;",
			"}",
			"",
			"private static long _extgcd(long a, long b, long[] x) {",
				"\tlong g = a;",
				"\tx[0] = 1;",
				"\tx[1] = 0;",
				"\tif (b != 0) {",
					"\t\tg = _extgcd(b, a % b, x);",
					"\t\tlong temp = x[0];",
					"\t\tx[0] = x[1];",
					"\t\tx[1] = temp;",
					"\t\tx[1] -= (a / b) * x[0];",
				"\t}",
				"\treturn g;",
			"}",
			"",
			"static long modpow(long a, long n) {",
				"\tlong res = 1;",
				"\twhile (n > 0) {",
					"\t\tif ((n & 1) != 0)",
						"\t\t\tres = res * a % mod;",
					"\t\ta = a * a % mod;",
					"\t\tn >>= 1;",
				"\t}",
				"\treturn res;",
			"}",
			""
		],
		"description": "剰余演算を行う add,sub,mul,div(加減乗除):O(1) fact(階乗):O(n) factInv(階乗の逆元):O(nlog p) comb(組み合わせ):O(1)(前計算O(nlog p)) mod_inverse(逆元):O(log p)　modpow(累乗の剰余):O(log p) stirling(スターリング数):O(n^2)"
	},
	"Dijkstra": {
		"prefix": "dijkstra",
		"body": ["public static long[] dijkstra(int s, Graph[] g) {",
					"\tlong[] d = new long[g.length];",
					"\tPriorityQueue<long[]> pq = new PriorityQueue<long[]>(new Comparator<long[]>() {",
						"\t\tpublic int compare(long[] a, long[] b) {",
							"\t\t\treturn Long.compare(a[1], b[1]);",
						"\t\t}",
					"\t});",
					"\tArrays.fill(d, 1L << 60);",
					"\td[s] = 0;",
					"\tpq.offer(new long[] { s, 0 });",
					"\twhile (!pq.isEmpty()) {",
						"\t\tlong[] p = pq.poll();",
						"\t\tint from = (int) p[0];",
						"\t\tif (d[from] != p[1])",
							"\t\t\tcontinue;",
						"\t\tfor (int i = 0; i < g[from].size(); i++) {",
							"\t\t\tlong[] e = g[from].get(i);",
							"\t\t\tint to = (int) e[0];",
							"\t\t\tif (d[to] > d[from] + e[1]) {",
								"\t\t\t\td[to] = d[from] + e[1];",
								"\t\t\t\tpq.offer(new long[] { to, d[to] });",
							"\t\t\t}",
						"\t\t}",
					"\t}",
					"\treturn d;",
				"}",
				"",
				"static class Graph extends ArrayList<long[]> {",
				"}",
				""
		],
		"description": "単一始点最短経路を求める O(ElogV)"
	},
	"Disjoint Sparse Table": {
		"prefix": "disjoint",
		"body": ["static class DisjointSparseTable {",
					"\tBinaryOperator<Long> f;",
					"\tlong[][] dat;",
					"\tlong[] ht;",
				"",
					"\tDisjointSparseTable(BinaryOperator<Long> f, long[] v) {",
						"\t\tthis.f = f;",
						"\t\tint n = v.length, h = 1;",
						"\t\twhile ((1 << h) <= n)",
							"\t\t\th++;",
						"\t\tdat = new long[h][n];",
						"\t\tht = new long[(1 << h) + 1];",
						"\t\tfor (int j = 2; j < (1 << h) + 1; j++)",
							"\t\t\tht[j] = ht[j >> 1] + 1;",
						"\t\tfor (int j = 0; j < n; j++)",
							"\t\t\tdat[0][j] = v[j];",
						"\t\tfor (int i = 1; i < h; i++) {",
							"\t\t\tint s = 1 << i;",
							"\t\t\tfor (int j = 0; j < n; j += s << 1) {",
								"\t\t\t\tint t = Math.min(j + s, n);",
								"\t\t\t\tdat[i][t - 1] = v[t - 1];",
								"\t\t\t\tfor (int k = t - 2; k >= j; k--)",
									"\t\t\t\t\tdat[i][k] = f.apply(v[k], dat[i][k + 1]);",
								"\t\t\t\tif (n <= t)",
									"\t\t\t\t\tbreak;",
								"\t\t\t\tdat[i][t] = v[t];",
								"\t\t\t\tint r = Math.min(t + s, n);",
								"\t\t\t\tfor (int k = t + 1; k < r; k++)",
									"\t\t\t\t\tdat[i][k] = f.apply(dat[i][k - 1], v[k]);",
							"\t\t\t}",
						"\t\t}",
					"\t}",
				"",
					"\t// [l,r)",
					"\tpublic long query(int l, int r) {",
						"\t\tif (l >= --r)",
							"\t\t\treturn dat[0][l];",
						"\t\treturn f.apply(dat[(int) ht[l ^ r]][l], dat[(int) ht[l ^ r]][r]);",
					"\t}",
				"",
					"\tpublic int length() {",
						"\t\treturn dat[0].length;",
					"\t}",
				"}",
				""
		],
		"description": "静的な区間に対して演算fを行う 構築:O(nlogn) query:O(1)"
	},
	"Topological Sort": {
		"prefix": "topological",
		"body": ["static int[] TopologicalSort(Graph[] g) {",
					"\tint n = g.length;",
					"\tint[] in = new int[n];",
					"\tint[] ord = new int[n];",
					"\tfor (int i = 0; i < n; i++) {",
						"\t\tfor (int to : gs[i])",
							"\t\t\tin[to]++;",
					"\t}",
					"\tDeque<Integer> s = new ArrayDeque<Integer>();",
					"\tfor (int i = 0; i < n; i++) {",
						"\t\tif (in[i] == 0) {",
							"\t\t\ts.offerFirst(i);",
						"\t\t}",
					"\t}",
					"\tint p = 0;",
					"\twhile (!s.isEmpty()) {",
						"\t\tint from = s.pollFirst();",
						"\t\tord[p++] = from;",
						"\t\tfor (int j = 0; j < g[from].size(); j++) {",
							"\t\t\tint to = g[from].get(j);",
							"\t\t\tin[to]--;",
							"\t\t\tif (in[to] == 0) {",
								"\t\t\t\ts.offerFirst(to);",
							"\t\t\t}",
						"\t\t}",
					"\t}",
					"\tfor (int i = 0; i < n; i++)",
						"\t\tif (in[i] != 0)",
							"\t\t\treturn null;",
					"\treturn ord;",
				"}",
				"",
				"static class Graph extends ArrayList<Integer> {}",
				""
			],
		"description": "トポロジカルソート O(V+E)"
	},
	"lower_bound": {
		"prefix": "lower_bound",
		"body": ["public static int lower_bound(long[] a, int fromIndex, int toIndex, long val) {",
					"\tif (val > a[toIndex])",
						"\t\treturn toIndex + 1;",
					"\tif (val <= a[fromIndex])",
						"\t\treturn fromIndex;",
					"\tint lb = fromIndex - 1, ub = toIndex;",
					"\twhile (ub - lb > 1) {",
						"\t\tint mid = (ub - lb)/2+lb;",
						"\t\tif (a[mid] >= val) {",
							"\t\t\tub = mid;",
						"\t\t} else {",
							"\t\t\tlb = mid;",
						"\t\t}",
					"\t}",
					"\treturn ub;",
				"}",
				""
			],
		"description": "二分探索(a[i]>=valとなる最小のiを求める) O(log n)"
	},
	"upper_bound": {
		"prefix": "upper_bound",
		"body": ["public static int upper_bound(long[] a, int fromIndex, int toIndex, long val) {",
					"\tif (val >= a[toIndex])",
						"\t\treturn toIndex + 1;",
					"\tif (val < a[fromIndex])",
						"\t\treturn fromIndex;",
					"\tint lb = fromIndex - 1, ub = toIndex;",
					"\twhile (ub - lb > 1) {",
						"\t\tint mid = (ub - lb)/2+lb;",
						"\t\tif (a[mid] > val) {",
							"\t\t\tub = mid;",
						"\t\t} else {",
							"\t\t\tlb = mid;",
						"\t\t}",
					"\t}",
					"\treturn ub;",
				"}",
				""
			],
		"description": "二分探索(a[i]>valとなる最小のiを求める) O(log n)"
	}
}
